# 锁的理解
java自带的锁有Synchronized关键字、java.util.concurrent.lock包下的锁以及Unsafe类中的CAS方法
## Synchronized关键字
Synchronized虽然经过一些优化，但是性能还是不太好，面对一些复杂的业务还是显得有点重量级。  
Synchronized保证了原子性、可见性、有序性。synchronized是可重入的，所以不会自己把自己锁死，synchronized锁一旦被占用，其他线程都会被阻塞。  
具体使用：  
1、修饰实例方法，对当前实例对象加锁  
2、修饰静态方法，对当前类的class对象加锁  
3、修饰代码块，对Synchronized括号内的对象加锁  
实现原理：  
JVM中主要通过对Monitor对象进入和退出实现锁的获取和释放。对同步方法来说，在同步方法的ACC_SYNCHRONIZED进行标记来获取Monitor对象；同步代码块则是通过monitor enter和monitor exit两条字节码指令实现的  
锁优化：  
1、偏向锁  
由经验数据得出，大多数情况下锁不仅不存在竞争，而且锁的获取总是由同一个线程获取。因此当同一个线程再次获取锁只需要判断是否有偏向锁的线程指向它，而不需要进入monitor去竞争锁了。  
2、轻量级锁  
但是一旦出现锁竞争，偏向锁就会升级为轻量级锁。第二个线程发现对象头中线程ID不是自己就会通过CAS操作去获取锁，如果获取成功，就会替换对象头的线程ID为自己的ID，锁会继续保持偏向锁；如果获取失败，则说明锁此时存在竞争，此时锁升级为轻量级锁。  
3、自旋策略  
当锁变成轻量级锁后，其他线程获取锁时不会直接阻塞，而是通过自旋的方式去获取锁，这也是基于经验，线程持有锁的时间不会太长，毕竟线程被挂起阻塞消耗有点大。  
4、重量级锁  
自旋失败会再次自旋，这会增大CPU的消耗，为了避免无谓的CPU消耗。自旋到达一定次数后，锁就会升级为重量级锁，此时未抢到锁的线程都会被阻塞挂起。  
5、锁消除  
虚拟机的即时编译器发现有一些同步代码检测到不可能发生数据竞争而产生锁的情况，会将锁进行消除。  
6、锁粗化  
如果虚拟机检测到一些零碎操作都是对同一个对象进行加锁，将会把加锁同步的范围粗化到整个范围里。  

## java.util.concurrent.lock包下的锁
java.util.concurrent.lock包下的锁其核心是AQS。通过acquire()方法获取锁，失败后通过addWaiter()方法将线程放入等待队列里。都是通过CAS方法进行操作。

## Unsafe类中的CAS方法
CAS翻译过来就是比较并交换。CAS操作包含三个值，内存位置(V)，预期值(A)，新值(B)。内存位置V上的值X与预期值A一致，则将新值B写入内存位置V中，否则，不更改进行更改，只需要告诉我当前值是即可。  
CAS应用非常广泛，例如我们经常使用的ConcurrentHashMap中就有大量用到CAS操作的地方，此外AQS也是基于CAS操作进行的。  
ABA问题  
通过版本号进行控制

## 锁的分类
1、乐观锁和悲观锁  
乐观锁认为一个线程获取数据时不会有其他线程竞争，例如CAS  
2、独享锁和共享锁  
独享锁是指该锁只能被一个线程获取，共享锁指该锁能同时被多个线程获取  
3、互斥锁和读写锁  
互斥锁其实就是独享锁的具体实现，例如synchronized、ReentrantLock；读写锁具体实现就是ReadWriteLock
