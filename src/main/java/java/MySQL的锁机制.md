# MySQL的锁机制  
对mysql锁的划分：  
1、按照锁的粒度：行锁、页锁、表锁  
2、按照锁的使用方式划分：共享锁和排它锁  
3、还有两种思想上的锁：悲观锁和乐观锁  
4、InnoDB中几种行级锁细分：Record Lock、Gap Lock、Next-key Lock  

## 1、行锁  
行级锁是mysql中粒度最小的锁，表示只对当前操作的行进行加锁操作。行级锁按照使用方式又分为共享锁和排它锁。  

**共享锁（读锁 S锁）**  
若事务T对数据对象A加上了S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁。这保证了其他事务可以读A。  
共享锁就是允许多个线程获取同一个锁，但是多个线程只能进行读操作。  

**排它锁（写锁 X锁）**  
若事务A对数据对象A加上了X锁，则事务T既可以读A也可以修改A，其他事务不能对A加S锁或X锁，直到T释放了A上的X锁。这保证了其他事务在T释放A上的锁之前不能对A进行操作。  
排它锁就是某一时刻只能被一个线程锁占有。  

## 2、表锁  
表级锁是mysql中粒度最大的锁，表示当前的操作对整张表进行加锁操作，资源开销比行锁小，不会出现死锁，但是冲突频繁。  

## 3、页锁  
页级锁介于行级锁与表级锁之间，一次锁定相邻的一组记录。  

## 4、乐观锁和悲观锁  
乐观锁和悲观锁是人定义出来的概念，一种思想。只是一种并发控制的方式。  

**悲观锁**  
指对数据被外界修改保持悲观的态度，因此，整个处理数据的过程中，将数据处于锁定状态。  

具体流程：  
```text
1、在对任意记录进行修改前，先尝试为该记录加上排它锁。  
2、如果加锁失败则说明该记录正在被修改，那么当前查询可能要等待或抛出异常。具体响应方式由开发者根据实际需要决定。  
3、如果加锁成功，就对记录进行修改操作，事务完成后释放锁。  
4、如果期间有其他要对该记录进行操作，都会等待我们解锁或直接抛出异常。  
```

悲观锁的优点和不足：  
悲观锁采用的是先锁在访问的策略，为数据的处理提供了安全保证，但是在效率方面由于额外的加锁机制导致资源开销加大，并且增加了死锁的机会。而且悲观锁降低了并发性，当一个事务处理一行数据时，其他事务只有在该事务处理完之后才能进行操作。  

**乐观锁**  
相较于悲观锁，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候才会正式对数据的冲突进行检验，如果发生冲突则返回用户错误信息，让用户决定如何去做。  

一般实现乐观锁是记录数据版本。  
```text
数据版本，为数据增加一个版本标识。当读取数据时，将版本标识的值一并读出，数据每更新一次，同时对版本标识进行更新。
当我们提交更新时，判断数据表对应记录的当前版本与第一次取出的版本是否相同，相同予以更新，否则认为过期数据。
```

乐观锁的优点和不足：  
乐观并发控制相信数据之间的冲突很少，因此尽可能的做下去，直到提交的时候才做判断。  

## 5、InnoDB锁特性  
1、在不通过索引条件查询时，InnoDB使用的是表锁。  
2、由于mysql的行锁是针对索引加的锁，不是对记录加的锁。访问不同行的记录时，使用的是相同的索引键就会产生锁冲突的。  
3、当表中有多个索引时，不同的事务可以使用不同的索引锁定不同行的数据。不论使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。  
4、即使条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描的效率更高，它就不会使用索引，这种情况下InnoDB将使用表锁。因此在分析锁冲突的时候也要看看执行计划。  

## 6、Record Lock、Gap Lock、Next-key Lock锁  
### 6.1、Record Lock  
单条索引上加锁，Record Lock永远锁的是索引，而不是数据本身。  
### 6.2、Gap Lock  
间隙锁是在索引的间隙之间加锁。  
### 6.3、Next-key Lock  
既锁住记录本身还锁住索引之间的间隙。  